<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>DeMa-AI</title>
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
		/>
		<style>
			:root {
				--primary: #3b82f6;
				--surface: #ffffff;
				--background: #f9fafb;
				--border: #e5e7eb;
				--text: #111827;
				--text-light: #6b7280;
				--sidebar: 320px;
				--navy-dark: #1e3a8a;
				--official-gold: #f59e0b;
				--white: #ffffff;
				--danger: #ef4444;
				--warning: #f59e0b;
				--success: #10b981;
				--info: #3b82f6;
				--danger-light: rgba(239, 68, 68, 0.1);
				--warning-light: rgba(245, 158, 11, 0.1);
				--success-light: rgba(16, 185, 129, 0.1);
			}

			body {
				margin: 0;
				padding: 0;
				font-family: -apple-system, BlinkMacSystemFont, sans-serif;
				background: var(--background);
				color: var(--text);
				height: 100vh;
				overflow: hidden;
			}

			.container {
				display: flex;
				height: 100vh;
				min-width: 0;
			}

			/* Control Panel - Left - FIXED WIDTH */
			.control-panel {
				width: var(--sidebar);
				min-width: var(--sidebar);
				max-width: var(--sidebar);
				background: var(--surface);
				border-right: 1px solid var(--border);
				display: flex;
				flex-direction: column;
				position: relative;
				flex-shrink: 0;
			}

			/* Logo Header */
			.logo-header {
				padding: 16px 16px 12px 16px;
				border-bottom: 1px solid var(--border);
				display: flex;
				align-items: center;
				gap: 12px;
				background: var(--surface);
				flex-shrink: 0;
			}

			.agency-seal {
				width: 40px;
				height: 40px;
				background: var(--white);
				border-radius: 50%;
				display: flex;
				align-items: center;
				justify-content: center;
				border: 2px solid var(--official-gold);
				flex-shrink: 0;
			}

			.agency-seal i {
				color: var(--navy-dark);
				font-size: 1.2rem;
			}

			.logo-text-container {
				display: flex;
				flex-direction: column;
				min-width: 0;
			}

			.logo-main {
				font-size: 18px;
				font-weight: 800;
				color: var(--navy-dark);
				line-height: 1.1;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}

			.logo-subtitle {
				font-size: 11px;
				font-weight: 500;
				color: var(--text-light);
				letter-spacing: 0.5px;
				margin-top: 2px;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}

			.control-content {
				padding: 16px;
				overflow-y: auto;
				flex: 1;
				min-width: 0;
				display: flex;
				flex-direction: column;
			}

			/* Upload Section */
			.upload-section {
				margin-top: 0;
			}

			.section-title {
				font-size: 13px;
				font-weight: 600;
				margin-bottom: 10px;
				color: var(--text);
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}

			.upload-box {
				border: 2px dashed var(--border);
				border-radius: 6px;
				padding: 30px 16px;
				text-align: center;
				cursor: pointer;
				margin-bottom: 16px;
				transition: all 0.3s ease;
				word-wrap: break-word;
				overflow-wrap: break-word;
				position: relative;
			}

			/* Default State */
			.upload-box:hover {
				border-color: var(--primary);
				background: rgba(59, 130, 246, 0.05);
			}

			/* Drag-Over State - SIMPLE HIGHLIGHT */
			.upload-box.dragover {
				border-color: var(--primary);
				background: rgba(59, 130, 246, 0.1);
			}

			/* Uploading State */
			.upload-box.uploading {
				border-color: var(--primary);
			}

			.upload-box.uploading i {
				animation: spin 1s linear infinite;
			}

			/* Invalid State (brief flash) */
			.upload-box.invalid {
				border-color: var(--danger);
				background: rgba(239, 68, 68, 0.05);
			}

			.upload-box i {
				font-size: 28px;
				margin-bottom: 8px;
				transition: all 0.3s ease;
			}

			.upload-box .upload-text {
				font-size: 13px;
				margin-bottom: 4px;
				word-wrap: break-word;
				transition: all 0.3s ease;
			}

			.upload-box .upload-subtext {
				font-size: 10px;
				color: var(--text-light);
				word-wrap: break-word;
				transition: all 0.3s ease;
			}

			/* File Info */
			.file-info {
				background: var(--background);
				padding: 12px;
				border-radius: 6px;
				margin-top: 16px;
				border: 1px solid var(--border);
				display: none;
				word-wrap: break-word;
				overflow-wrap: break-word;
			}

			.file-info.active {
				display: block;
			}

			.file-name {
				font-weight: 600;
				margin-bottom: 4px;
				font-size: 13px;
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			}

			.file-size {
				font-size: 11px;
				color: var(--text-light);
			}

			/* Results Section */
			.results {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 8px;
				margin-top: 16px;
			}

			.result-box {
				background: var(--background);
				padding: 10px;
				border-radius: 5px;
				text-align: center;
				opacity: 0.6;
				transition: opacity 0.3s;
				min-width: 0;
			}

			.result-box.active {
				opacity: 1;
				box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
			}

			.result-value {
				font-size: 15px;
				font-weight: 600;
				margin: 4px 0;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}

			.result-label {
				font-size: 10px;
				color: var(--text-light);
				text-transform: uppercase;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}

			/* Threat Bars Container - REPLACES RADAR */
			.threat-bars-container {
				margin-top: 20px;
				flex: 1;
				display: flex;
				flex-direction: column;
				min-height: 250px;
			}

			.threat-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 12px;
			}

			.threat-title {
				font-size: 13px;
				font-weight: 600;
				color: var(--text);
			}

			.threat-level {
				font-size: 11px;
				font-weight: 600;
				padding: 3px 8px;
				border-radius: 10px;
				background: var(--background);
				border: 1px solid var(--border);
			}

			.threat-level.high {
				background: var(--danger-light);
				color: var(--danger);
				border-color: rgba(239, 68, 68, 0.3);
			}

			.threat-level.medium {
				background: var(--warning-light);
				color: var(--warning);
				border-color: rgba(245, 158, 11, 0.3);
			}

			.threat-level.low {
				background: var(--success-light);
				color: var(--success);
				border-color: rgba(16, 185, 129, 0.3);
			}

			.threat-level.unknown {
				color: var(--text-light);
			}

			.threat-bars-wrapper {
				flex: 1;
				min-height: 200px;
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 6px;
				padding: 12px;
				overflow-y: auto;
			}

			.threat-placeholder {
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				height: 100%;
				color: var(--text-light);
				text-align: center;
				padding: 20px;
			}

			.threat-placeholder i {
				font-size: 32px;
				margin-bottom: 10px;
				color: var(--border);
			}

			.threat-placeholder-text {
				font-size: 11px;
				line-height: 1.4;
			}

			/* Threat Bar Styles */
			.threat-bar {
				margin-bottom: 10px;
				position: relative;
			}

			.threat-bar-label {
				display: flex;
				justify-content: space-between;
				margin-bottom: 4px;
				font-size: 11px;
			}

			.threat-name {
				font-weight: 600;
				color: var(--text);
				text-transform: uppercase;
				letter-spacing: 0.3px;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				flex-shrink: 0;
				width: 120px;
			}

			.threat-percentage {
				font-weight: 600;
				color: var(--text-light);
				flex-shrink: 0;
				width: 40px;
				text-align: right;
			}

			.threat-bar-track {
				height: 8px;
				background: var(--background);
				border-radius: 4px;
				overflow: hidden;
				position: relative;
				cursor: pointer;
			}

			.threat-bar-fill {
				height: 100%;
				border-radius: 4px;
				transition: width 0.8s ease-out;
				min-width: 8px; /* Ensures visibility even at 0% */
				position: relative;
			}

			/* Color coding based on percentage */
			.threat-bar-fill.high {
				background: linear-gradient(90deg, var(--danger), #dc2626);
			}

			.threat-bar-fill.medium {
				background: linear-gradient(90deg, var(--warning), #d97706);
			}

			.threat-bar-fill.low {
				background: linear-gradient(90deg, var(--success), #059669);
			}

			.threat-bar-fill.none {
				background: var(--border);
			}

			/* Pattern for empty bars */
			.threat-bar-fill.empty {
				background: repeating-linear-gradient(
					45deg,
					var(--border),
					var(--border) 2px,
					transparent 2px,
					transparent 6px
				);
				width: 100% !important;
			}

			/* Tooltip Styles */
			.threat-tooltip {
				position: absolute;
				background: var(--text);
				color: white;
				padding: 8px 12px;
				border-radius: 6px;
				font-size: 11px;
				line-height: 1.4;
				z-index: 1000;
				white-space: nowrap;
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
				pointer-events: none;
				opacity: 0;
				transition: opacity 0.2s;
				max-width: 300px;
			}

			.threat-tooltip::after {
				content: "";
				position: absolute;
				bottom: 100%;
				left: 10px;
				border-width: 6px;
				border-style: solid;
				border-color: transparent transparent var(--text) transparent;
			}

			.threat-tooltip.show {
				opacity: 1;
			}

			.threat-tooltip strong {
				display: block;
				margin-bottom: 4px;
				font-size: 12px;
				color: white;
			}

			.threat-tooltip small {
				color: #d1d5db;
				font-size: 10px;
			}

			/* Code Panel - Right */
			.code-panel {
				flex: 1;
				display: flex;
				flex-direction: column;
				background: var(--surface);
				min-width: 0;
			}

			/* Code Header with Tab-Button Pairs - FIXED FOR OVERLAPPING */
			.code-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				padding: 0 16px;
				background: var(--surface);
				border-bottom: 1px solid var(--border);
				height: 56px;
				flex-shrink: 0;
				min-width: 0;
			}

			.tab-container {
				display: flex;
				gap: 6px;
				flex: 1;
				min-width: 0;
				overflow-x: auto;
				padding: 2px 0;
			}

			.tab-button-pair {
				display: flex;
				align-items: center;
				border: 1px solid var(--border);
				border-radius: 5px;
				overflow: hidden;
				transition: all 0.2s;
				flex-shrink: 0;
			}

			.tab-button-pair.active {
				border-color: var(--primary);
			}

			.tab-label {
				padding: 5px 10px;
				border: none;
				background: none;
				cursor: pointer;
				color: var(--text-light);
				font-size: 13px;
				display: flex;
				align-items: center;
				gap: 6px;
				transition: all 0.2s;
				white-space: nowrap;
				min-width: 0;
			}

			.tab-button-pair.active .tab-label {
				color: var(--primary);
				background: rgba(59, 130, 246, 0.05);
			}

			.tab-label i {
				font-size: 14px;
				flex-shrink: 0;
			}

			.play-button {
				padding: 10px 12px;
				border: none;
				background: var(--primary);
				color: white;
				cursor: pointer;
				font-size: 12px;
				display: flex;
				align-items: center;
				gap: 4px;
				transition: all 0.2s;
				border-left: 1px solid rgba(255, 255, 255, 0.2);
				flex-shrink: 0;
			}

			.play-button:hover {
				background: #2563eb;
			}

			.play-button i {
				font-size: 12px;
			}

			/* Raw Code tab has no play button */
			.tab-button-pair.raw-code {
				border-radius: 5px;
			}

			.tab-button-pair.raw-code .tab-label {
				border-radius: 5px;
			}

			.utility-buttons {
				display: flex;
				gap: 8px;
				flex-shrink: 0;
				margin-left: 8px;
			}

			.util-btn {
				padding: 8px 12px;
				border: 1px solid var(--border);
				background: var(--surface);
				cursor: pointer;
				color: var(--text);
				border-radius: 5px;
				font-size: 12px;
				display: flex;
				align-items: center;
				gap: 5px;
				transition: all 0.2s;
				flex-shrink: 0;
				white-space: nowrap;
			}

			.util-btn:hover {
				background: var(--background);
			}

			.util-btn.primary {
				background: var(--primary);
				color: white;
				border-color: var(--primary);
			}

			.code-area {
				flex: 1;
				overflow: auto;
				position: relative;
				min-width: 0;
			}

			/* Ghidra Watermark - Only shows when Ghidra tab is active */
			.ghidra-watermark {
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background-image: url("https://media.defense.gov/2019/Apr/04/2002109557/1088/820/0/190404-D-IM742-1002.PNG");
				background-size: 250px 250px;
				background-repeat: no-repeat;
				background-position: center;
				opacity: 0.08;
				pointer-events: none;
				z-index: 0;
				display: none;
			}

			.ghidra-watermark.active {
				display: block;
			}

			/* Security Report Styles - CLEAN FORMATTING */
			.security-report {
				padding: 20px;
				font-family: "Menlo", "Monaco", "Courier New", monospace;
				font-size: 11px;
				line-height: 1.4;
				background: white;
				overflow-x: auto;
			}

			.security-report table {
				border-collapse: collapse;
				width: 100%;
				margin: 20px 0;
				table-layout: fixed;
			}

			.security-report th,
			.security-report td {
				border: 1px solid #000;
				padding: 6px 8px;
				vertical-align: top;
				text-align: left;
				word-wrap: break-word;
				overflow-wrap: break-word;
				white-space: normal;
			}

			.security-report th {
				background-color: #f0f0f0;
				font-weight: bold;
			}

			/* Column-specific widths */
			.security-report th:nth-child(1),
			.security-report td:nth-child(1) {
				/* No. */
				width: 40px;
				text-align: center;
			}

			.security-report th:nth-child(2),
			.security-report td:nth-child(2) {
				/* Function Name */
				width: 150px;
			}

			.security-report th:nth-child(3),
			.security-report td:nth-child(3) {
				/* Status */
				width: 80px;
				text-align: center;
			}

			.security-report th:nth-child(4),
			.security-report td:nth-child(4) {
				/* Behaviors/APIs */
				width: 180px;
			}

			.security-report th:nth-child(5),
			.security-report td:nth-child(5) {
				/* Main Threat & Explanation */
				width: auto;
				min-width: 300px;
				text-align: left;
			}

			/* Explanation cell styling */
			.security-report td:nth-child(5) {
				line-height: 1.4;
			}

			.security-report td:nth-child(5) strong {
				color: #000;
				font-weight: bold;
				display: block;
				margin: 4px 0 2px 0;
			}

			.security-report td:nth-child(5) br {
				display: block;
				margin-bottom: 3px;
				content: "";
			}

			/* API list styling */
			.security-report td:nth-child(4) small {
				color: #555;
				font-size: 9px;
				display: block;
				margin-top: 2px;
				font-family: "Menlo", "Monaco", monospace;
			}

			.security-report .report-header {
				margin-bottom: 10px;
				padding-bottom: 10px;
				border-bottom: 1px solid #ccc;
			}

			.security-report .report-title {
				font-size: 14px;
				font-weight: bold;
				margin-bottom: 5px;
				color: #000;
			}

			.security-report .report-meta {
				margin-bottom: 3px;
				font-size: 11px;
				color: #555;
			}

			.security-report .section-divider {
				border-top: 2px solid #666;
				margin: 20px 0;
				padding-top: 15px;
			}

			.security-report .recommendation {
				white-space: pre-line;
				line-height: 1.6;
				margin-top: 10px;
				padding: 12px;
				background-color: #f8f9fa;
				border: 1px solid #dee2e6;
				border-radius: 4px;
				font-size: 12px;
				color: #333;
			}

			/* Function name styling */
			.security-report td:nth-child(2) {
				font-weight: bold;
				font-family: "Menlo", "Monaco", monospace;
			}

			.security-report td:nth-child(2) small {
				font-weight: normal;
				color: #666;
				font-size: 9px;
				display: block;
			}

			.code-display {
				font-family: "Menlo", "Monaco", "Courier New", monospace;
				font-size: 12px;
				line-height: 1.5;
				padding: 16px;
				white-space: pre-wrap;
				word-wrap: break-word;
				overflow-wrap: break-word;
				tab-size: 4;
				min-height: 100%;
				position: relative;
				z-index: 1;
				background: transparent;
				overflow-x: auto;
			}

			.status-bar {
				background: var(--surface);
				border-top: 1px solid var(--border);
				padding: 8px 16px;
				display: flex;
				justify-content: space-between;
				font-size: 11px;
				color: var(--text-light);
				flex-shrink: 0;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}

			/* Progress Overlay */
			.progress-overlay {
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: rgba(0, 0, 0, 0.7);
				display: none;
				align-items: center;
				justify-content: center;
				z-index: 1000;
			}

			.progress-card {
				background: white;
				padding: 24px;
				border-radius: 10px;
				text-align: center;
				min-width: 280px;
				box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
			}

			.progress-text {
				margin-bottom: 12px;
				color: var(--text);
				font-weight: 500;
				font-size: 14px;
			}

			.progress-bar {
				height: 5px;
				background: var(--border);
				border-radius: 3px;
				overflow: hidden;
			}

			.progress-fill {
				height: 100%;
				width: 0%;
				background: linear-gradient(90deg, #3b82f6, #8b5cf6);
				transition: width 0.3s ease;
			}

			/* Modal Overlay */
			.modal-overlay {
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: rgba(0, 0, 0, 0.7);
				display: none;
				align-items: center;
				justify-content: center;
				z-index: 2000;
			}

			.modal-content {
				background: white;
				padding: 24px;
				border-radius: 10px;
				max-width: 500px;
				width: 90%;
				max-height: 80vh;
				overflow-y: auto;
				box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
			}

			.modal-title {
				font-size: 18px;
				font-weight: 600;
				margin-bottom: 16px;
				color: var(--danger);
				display: flex;
				align-items: center;
				gap: 8px;
			}

			.modal-body {
				margin-bottom: 20px;
				font-size: 14px;
				line-height: 1.5;
			}

			.modal-actions {
				display: flex;
				justify-content: flex-end;
				gap: 10px;
			}

			.modal-btn {
				padding: 8px 16px;
				border: none;
				border-radius: 5px;
				cursor: pointer;
				font-size: 13px;
			}

			.modal-btn.primary {
				background: var(--primary);
				color: white;
			}

			.modal-btn.secondary {
				background: var(--background);
				color: var(--text);
				border: 1px solid var(--border);
			}

			/* Hide scrollbar for tab container */
			.tab-container::-webkit-scrollbar {
				display: none;
			}

			.tab-container {
				-ms-overflow-style: none;
				scrollbar-width: none;
			}
			.tab-icon {
				width: 18px;
				height: 18px;
				object-fit: contain;
				vertical-align: middle;
				margin-right: 6px;
			}

			/* Threat legend */
			.threat-legend {
				display: flex;
				justify-content: space-between;
				margin-top: 8px;
				font-size: 9px;
			}

			.legend-item {
				display: flex;
				align-items: center;
				gap: 3px;
			}

			.legend-color {
				width: 8px;
				height: 8px;
				border-radius: 50%;
			}

			.legend-color.red {
				background: var(--danger);
			}

			.legend-color.orange {
				background: var(--warning);
			}

			.legend-color.green {
				background: var(--success);
			}

			/* Animations */
			@keyframes spin {
				0% {
					transform: rotate(0deg);
				}
				100% {
					transform: rotate(360deg);
				}
			}

			/* Calculation Guide Styles */
			.calculation-example {
				padding: 16px;
				line-height: 1.6;
				font-size: 13px;
			}

			/* Responsive adjustments for threat bars */
			@media (max-width: 1400px) {
				.threat-name {
					width: 100px;
					font-size: 10px;
				}
				.threat-percentage {
					font-size: 10px;
				}
			}

			@media (max-height: 800px) {
				.threat-bar {
					margin-bottom: 8px;
				}
				.threat-bars-wrapper {
					padding: 10px;
				}
			}
		</style>
	</head>
	<body>
		<div class="container">
			<!-- Left: Control Panel -->
			<div class="control-panel">
				<!-- Logo Header -->
				<div class="logo-header">
					<div class="agency-seal">
						<i class="fas fa-shield-alt"></i>
					</div>
					<div class="logo-text-container">
						<div class="logo-main">DeMa-AI</div>
						<div class="logo-subtitle">Analysis Platform</div>
					</div>
				</div>

				<div class="control-content">
					<!-- File Upload Area -->
					<div class="upload-section">
						<div class="section-title">Upload File</div>
						<div class="upload-box" id="uploadBox">
							<i class="fas fa-cloud-upload-alt" id="uploadIcon"></i>
							<div class="upload-text" id="uploadText">
								Drop file here or click to upload
							</div>
							<div class="upload-subtext" id="uploadSubtext">
								.bin .exe .o .obj .elf .so .dll .py
							</div>
						</div>

						<div class="file-info" id="fileInfo">
							<div class="file-name" id="fileName">No file selected</div>
							<div class="file-size" id="fileSize">—</div>
						</div>
					</div>

					<!-- Results -->
					<div class="section-title">Analysis Results</div>
					<div class="results">
						<div class="result-box" id="resultComplexity">
							<div class="result-label">Complexity</div>
							<div class="result-value">—</div>
						</div>
						<div class="result-box" id="resultThreat">
							<div class="result-label">Threat</div>
							<div class="result-value">—</div>
						</div>
						<div class="result-box" id="resultVulns">
							<div class="result-label">Vulns</div>
							<div class="result-value">—</div>
						</div>
						<div class="result-box" id="resultSize">
							<div class="result-label">Size</div>
							<div class="result-value">—</div>
						</div>
					</div>

					<!-- Threat Bars - REPLACES RADAR CHART -->
					<div class="threat-bars-container">
						<div class="threat-header">
							<div class="threat-title">Threat Analysis</div>
							<div class="threat-level" id="threatLevel">No Data</div>
						</div>
						<div class="threat-bars-wrapper" id="threatBarsWrapper">
							<div class="threat-placeholder" id="threatPlaceholder">
								<i class="fas fa-chart-bar"></i>
								<div class="threat-placeholder-text">
									Run security analysis to<br />display threat assessment
								</div>
							</div>
							<!-- Threat bars will be dynamically inserted here -->
						</div>
						<div class="threat-legend">
							<div class="legend-item">
								<div class="legend-color red"></div>
								<span>High Risk (>70%)</span>
							</div>
							<div class="legend-item">
								<div class="legend-color orange"></div>
								<span>Medium Risk (40-70%)</span>
							</div>
							<div class="legend-item">
								<div class="legend-color green"></div>
								<span>Low Risk (<40%)</span>
							</div>
						</div>
					</div>
				</div>
			</div>

			<!-- Right: Code Display -->
			<div class="code-panel">
				<!-- Header with Tab-Button Pairs -->
				<div class="code-header">
					<div class="tab-container">
						<!-- Raw Code Display - No Play Button -->
						<div class="tab-button-pair raw-code active" data-view="raw">
							<button class="tab-label" data-action="switch">
								<i class="fas fa-file-code"></i>
								Raw Code
							</button>
						</div>

						<!-- Ghidra Tab-Button Pair -->
						<div class="tab-button-pair" data-view="ghidra">
							<button class="tab-label" data-action="switch">
								<img
									src="https://media.defense.gov/2019/Apr/04/2002109557/1088/820/0/190404-D-IM742-1002.PNG"
									alt="Ghidra"
									class="tab-icon"
								/>
								Ghidra Output
							</button>

							<button class="play-button" data-action="calculate">
								<i class="fas fa-play"></i>
							</button>
						</div>

						<!-- Heuristic Enhanced Tab-Button Pair -->
						<div class="tab-button-pair" data-view="heuristic">
							<button class="tab-label" data-action="switch">
								<i class="fas fa-wand-magic-sparkles"></i>
								Heuristic Enhanced
							</button>
							<button class="play-button" data-action="calculate">
								<i class="fas fa-play"></i>
							</button>
						</div>

						<!-- Security Tab-Button Pair -->
						<div class="tab-button-pair" data-view="security">
							<button class="tab-label" data-action="switch">
								<i class="fas fa-shield-alt"></i>
								Security
							</button>
							<button class="play-button" data-action="calculate">
								<i class="fas fa-play"></i>
							</button>
						</div>

						<!-- NEW: Calculation Guide Tab - No Play Button -->
						<div class="tab-button-pair raw-code" data-view="calculation">
							<button class="tab-label" data-action="switch">
								<i class="fas fa-calculator"></i>
								Calculation Guide
							</button>
						</div>
					</div>

					<div class="utility-buttons">
						<button class="util-btn" data-action="copy">
							<i class="fas fa-copy"></i>
							Copy
						</button>
						<button class="util-btn primary" data-action="download">
							<i class="fas fa-download"></i>
							Export
						</button>
					</div>
				</div>

				<div class="code-area">
					<!-- Ghidra Watermark -->
					<div class="ghidra-watermark" id="ghidraWatermark"></div>

					<pre class="code-display" id="codeContent">
// Select a file to begin analysis
// Supported formats: .bin, .exe, .o, .obj, .elf, .so, .dll, .py
//
// Upload a file to see raw binary content
// Other tabs require clicking the play button (▶) to run analysis
                </pre
					>
				</div>

				<div class="status-bar">
					<div id="statusInfo">No file uploaded</div>
					<div id="statusReady">Ready - Raw Code view selected</div>
				</div>
			</div>

			<!-- Progress Overlay -->
			<div class="progress-overlay" id="progressOverlay">
				<div class="progress-card">
					<div class="progress-text" id="progressText">Processing...</div>
					<div class="progress-bar">
						<div class="progress-fill" id="progressFill"></div>
					</div>
				</div>
			</div>

			<!-- Error Modal -->
			<div class="modal-overlay" id="errorModal">
				<div class="modal-content">
					<div class="modal-title">
						<i class="fas fa-exclamation-triangle"></i>
						<span id="modalTitle">Error</span>
					</div>
					<div class="modal-body" id="modalBody">
						Error message will appear here.
					</div>
					<div class="modal-actions">
						<button class="modal-btn secondary" onclick="hideModal()">
							Close
						</button>
						<button class="modal-btn primary" onclick="hideModal()">OK</button>
					</div>
				</div>
			</div>
		</div>

		<script>
			// DOM Elements
			const uploadBox = document.getElementById("uploadBox");
			const uploadIcon = document.getElementById("uploadIcon");
			const uploadText = document.getElementById("uploadText");
			const uploadSubtext = document.getElementById("uploadSubtext");
			const fileInfo = document.getElementById("fileInfo");
			const fileName = document.getElementById("fileName");
			const fileSize = document.getElementById("fileSize");
			const tabButtonPairs = document.querySelectorAll(".tab-button-pair");
			const tabLabels = document.querySelectorAll(".tab-label");
			const playButtons = document.querySelectorAll(".play-button");
			const utilBtns = document.querySelectorAll(".util-btn");
			const resultBoxes = document.querySelectorAll(".result-box");
			const statusInfo = document.getElementById("statusInfo");
			const statusReady = document.getElementById("statusReady");
			const progressOverlay = document.getElementById("progressOverlay");
			const progressFill = document.getElementById("progressFill");
			const progressText = document.getElementById("progressText");
			const codeContent = document.getElementById("codeContent");
			const ghidraWatermark = document.getElementById("ghidraWatermark");
			const threatLevel = document.getElementById("threatLevel");
			const threatPlaceholder = document.getElementById("threatPlaceholder");
			const threatBarsWrapper = document.getElementById("threatBarsWrapper");
			const errorModal = document.getElementById("errorModal");
			const modalTitle = document.getElementById("modalTitle");
			const modalBody = document.getElementById("modalBody");

			// Current state
			let currentFile = null;
			let currentView = "raw";
			let fileContent = null;
			let decompiledCode = null;
			let enhancedCode = null;
			let securityData = null;
			let languageInfo = null;

			// Security categories (must match backend)
			const SECURITY_CATEGORIES = [
				"DATA_EXFILTRATION",
				"PERSISTENCE",
				"PRIVILEGE_ESCALATION",
				"SURVEILLANCE",
				"DESTRUCTIVE",
				"EVASION",
				"DENIAL_OF_SERVICE",
				"CREDENTIAL_THEFT",
			];

			// Supported file extensions
			const SUPPORTED_EXTENSIONS = [
				".bin",
				".exe",
				".o",
				".obj",
				".elf",
				".so",
				".dll",
				".py",
			];

			// ==================== DRAG & DROP IMPLEMENTATION ====================

			// Prevent default drag behaviors
			["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
				uploadBox.addEventListener(eventName, preventDefaults, false);
			});

			function preventDefaults(e) {
				e.preventDefault();
				e.stopPropagation();
			}

			// Simple highlight - NO VALIDATION during drag
			["dragenter", "dragover"].forEach((eventName) => {
				uploadBox.addEventListener(eventName, highlight, false);
			});

			["dragleave", "drop"].forEach((eventName) => {
				uploadBox.addEventListener(eventName, unhighlight, false);
			});

			function highlight(e) {
				uploadBox.classList.add("dragover");
				uploadText.textContent = "Drop to upload";
				uploadSubtext.textContent = "Release file here";
			}

			function unhighlight(e) {
				uploadBox.classList.remove("dragover");
				uploadText.textContent = "Drop file here or click to upload";
				uploadSubtext.textContent = ".bin .exe .o .obj .elf .so .dll .py";
			}

			// Handle dropped files
			uploadBox.addEventListener("drop", handleDrop, false);

			function handleDrop(e) {
				const dt = e.dataTransfer;
				const files = dt.files;

				if (files.length > 0) {
					// Take the first file only
					const file = files[0];

					// Check if file type is supported (REAL validation here)
					if (isFileTypeSupported(file.name)) {
						// Show uploading state
						uploadBox.classList.add("uploading");
						uploadText.textContent = "Uploading...";
						uploadSubtext.textContent = "Processing file";
						uploadIcon.className = "fas fa-spinner";

						// Process immediately
						handleFileUpload(file);
					} else {
						// Show brief error flash
						uploadBox.classList.add("invalid");
						setTimeout(() => {
							uploadBox.classList.remove("invalid");
						}, 1000);

						showError(
							"Unsupported File Type",
							`"${file.name}" is not a supported format.\n\nSupported formats: .bin, .exe, .o, .obj, .elf, .so, .dll .py`
						);
					}
				}
			}

			// Check if file type is supported
			function isFileTypeSupported(filename) {
				if (!filename || filename.indexOf(".") === -1) return false;
				const extension = filename
					.toLowerCase()
					.substring(filename.lastIndexOf("."));
				return SUPPORTED_EXTENSIONS.includes(extension);
			}

			// ==================== EVENT LISTENERS ====================

			// Upload box click (existing functionality)
			uploadBox.addEventListener("click", () => {
				const input = document.createElement("input");
				input.type = "file";
				input.accept = ".bin,.exe,.o,.obj,.elf,.so,.dll,.py";

				input.addEventListener("change", (e) => {
					if (e.target.files.length > 0) {
						handleFileUpload(e.target.files[0]);
					}
				});

				input.click();
			});

			// Tab label click - switch view immediately
			tabLabels.forEach((label) => {
				label.addEventListener("click", function () {
					const pair = this.closest(".tab-button-pair");
					const view = pair.dataset.view;

					// Update active tab
					tabButtonPairs.forEach((p) => p.classList.remove("active"));
					pair.classList.add("active");
					currentView = view;

					// Show/hide watermark for Ghidra view
					if (view === "ghidra" || view === "heuristic") {
						ghidraWatermark.classList.add("active");
					} else {
						ghidraWatermark.classList.remove("active");
					}

					// Show the view content immediately
					showView(view);
				});
			});

			// Play button click - run calculation for that specific view
			playButtons.forEach((button) => {
				button.addEventListener("click", function () {
					if (!currentFile) {
						showError(
							"File Required",
							"Please upload a file first to run analysis"
						);
						return;
					}

					const pair = this.closest(".tab-button-pair");
					const view = pair.dataset.view;

					// Run calculation for this specific view
					performCalculation(view);
				});
			});

			// Utility button actions
			utilBtns.forEach((btn) => {
				btn.addEventListener("click", function () {
					const action = this.dataset.action;

					if (action === "copy") {
						navigator.clipboard.writeText(codeContent.textContent);
						showNotification("Code copied to clipboard");
					} else if (action === "download") {
						if (!currentFile) {
							showError("No File", "Please upload a file first");
							return;
						}
						exportCurrentView();
					}
				});
			});

			// ==================== FILE HANDLING ====================

			// Handle file upload
			function handleFileUpload(file) {
				// Validate file type before proceeding
				if (!isFileTypeSupported(file.name)) {
					showError(
						"Unsupported File Type",
						`"${file.name}" is not a supported format.\n\nSupported formats: .bin, .exe, .o, .obj, .elf, .so, .dll, .py`
					);
					return; // Exit without processing
				}

				currentFile = file;

				// Update file info
				fileName.textContent = file.name;
				fileSize.textContent = formatFileSize(file.size);
				fileInfo.classList.add("active");

				// Update status
				statusInfo.textContent = `File: ${file.name} (${formatFileSize(
					file.size
				)})`;

				// Show processing
				showProgress("Uploading file...", 1000, () => {
					// Read file content for raw view
					const reader = new FileReader();
					reader.onload = function (e) {
						fileContent = e.target.result;

						// Reset results
						resultBoxes.forEach((box) => {
							box.classList.remove("active");
							box.querySelector(".result-value").textContent = "—";
						});

						// Reset threat bars
						resetThreatBars();

						// Reset stored data
						decompiledCode = null;
						enhancedCode = null;
						securityData = null;
						languageInfo = null;

						// Automatically run language classification
						classifyLanguage(file);

						// Show raw content
						showView("raw");

						showNotification(
							"File uploaded successfully. Language classification in progress."
						);

						// Reset upload box UI
						uploadBox.classList.remove("uploading");
						uploadText.textContent = "Drop file here or click to upload";
						uploadSubtext.textContent = ".bin .exe .o .obj .elf .so .dll, .py";
						uploadIcon.className = "fas fa-cloud-upload-alt";
					};

					if (file.name.endsWith(".o") || file.name.endsWith(".obj")) {
						reader.readAsText(file);
					} else {
						reader.readAsArrayBuffer(file);
					}
				});
			}

			// ==================== API INTEGRATION ====================

			// Classify language automatically
			async function classifyLanguage(file) {
				// Shortcut: Python files
				if (file.name.toLowerCase().endsWith(".py")) {
					const data = {
						language: "Python",
						confidence: 1.0,
					};

					languageInfo = data;

					statusInfo.textContent = `File: ${file.name} | Language: Python (100% confidence)`;
					showNotification("Language detected: Python with 100% confidence");
					return;
				}

				const formData = new FormData();
				formData.append("file", file);

				try {
					const response = await fetch("/classify", {
						method: "POST",
						body: formData,
					});

					if (!response.ok) {
						throw new Error(`Classification failed: ${response.status}`);
					}

					const data = await response.json();
					languageInfo = data;

					if (data.language && data.language !== "Unknown") {
						statusInfo.textContent = `File: ${file.name} | Language: ${
							data.language
						} (${Math.round(data.confidence * 100)}% confidence)`;
						showNotification(
							`Language detected: ${data.language} with ${Math.round(
								data.confidence * 100
							)}% confidence`
						);
					}
				} catch (error) {
					console.log("Language classification failed:", error);
				}
			}

			// Perform calculation for a view
			async function performCalculation(view) {
				if (!currentFile) {
					showError("No File", "Please upload a file first");
					return;
				}

				const endpoints = {
					ghidra: "/ghidra_decompile",
					heuristic: "/ghidra_enhance",
					security: "/security_analyze",
				};

				const endpoint = endpoints[view];
				if (!endpoint) {
					showError("Invalid View", "This view is not supported");
					return;
				}

				// Check if we need Ghidra output for security analysis
				if (view === "security") {
					const hasGhidra = await checkGhidraOutput();
					if (!hasGhidra) {
						showError(
							"No Decompiled Code",
							"Please run Ghidra decompilation first before security analysis"
						);
						return;
					}

					showProgress("Running security analysis...", 0);

					try {
						const response = await fetch(endpoint, {
							method: "POST",
						});

						const result = await response.json();

						if (!response.ok) {
							throw new Error(
								result.error || `Server returned ${response.status}`
							);
						}

						securityData = result;
						showProgress("Processing security analysis...", 1000, () => {
							displaySecurityResultHTML(result);
							updateThreatBarsFromSecurity(result);
							updateResultsFromSecurity(result);
							showNotification("Security analysis completed successfully");
						});
					} catch (error) {
						hideProgress();
						showError(
							"Security Analysis Failed",
							error.message || "An error occurred during security analysis"
						);
						console.error("Security analysis error:", error);
					}

					return;
				}

				// For Ghidra decompilation/enhancement
				const formData = new FormData();
				formData.append("file", currentFile);

				showProgress(
					`Running ${
						view === "ghidra" ? "Ghidra decompilation" : "heuristic enhancement"
					}...`,
					0
				);

				try {
					const response = await fetch(endpoint, {
						method: "POST",
						body: formData,
					});

					const result = await response.json();

					if (!response.ok) {
						throw new Error(
							result.error || `Server returned ${response.status}`
						);
					}

					// Process based on view
					if (view === "ghidra") {
						decompiledCode = result.decompiled_code;
						showProgress("Processing Ghidra output...", 1000, () => {
							displayGhidraResult(result);
							showNotification("Ghidra decompilation completed successfully");
						});
					} else if (view === "heuristic") {
						enhancedCode = result.decompiled_code;
						showProgress("Processing enhanced output...", 1000, () => {
							displayEnhancedResult(result);
							showNotification("Heuristic enhancement completed successfully");
						});
					}
				} catch (error) {
					hideProgress();
					showError(
						"Analysis Failed",
						error.message || "An error occurred during analysis"
					);
					console.error(`${view} analysis error:`, error);
				}
			}

			// Check if Ghidra output exists
			async function checkGhidraOutput() {
				try {
					const response = await fetch("/get_current_file");
					const data = await response.json();
					return data.exists === true;
				} catch (error) {
					return false;
				}
			}

			// ==================== DISPLAY FUNCTIONS ====================

			// Show specific view
			function showView(view) {
				ghidraWatermark.classList.remove("active");

				switch (view) {
					case "raw":
						if (fileContent && currentFile) {
							codeContent.textContent = getRawContentView();
							statusReady.textContent =
								"Raw Code view - File content displayed";
						} else {
							codeContent.textContent = getRawView();
							statusReady.textContent = "Raw Code view - No file uploaded";
						}
						break;
					case "ghidra":
						ghidraWatermark.classList.add("active");

						if (decompiledCode) {
							codeContent.textContent = decompiledCode;
							statusReady.textContent =
								"Ghidra Output view - Decompilation complete";
						} else if (currentFile) {
							codeContent.textContent = getGhidraView();
							statusReady.textContent =
								"Ghidra Output view - Ready for analysis";
						} else {
							codeContent.textContent = getGhidraView();
							statusReady.textContent =
								"Ghidra Output view - Upload a file first";
						}
						break;
					case "heuristic":
						ghidraWatermark.classList.add("active");

						if (enhancedCode) {
							codeContent.textContent = enhancedCode;
							statusReady.textContent =
								"Heuristic Enhanced view - Enhancement complete";
						} else if (currentFile) {
							codeContent.textContent = getHeuristicView();
							statusReady.textContent =
								"Heuristic Enhanced view - Ready for analysis";
						} else {
							codeContent.textContent = getHeuristicView();
							statusReady.textContent =
								"Heuristic Enhanced view - Upload a file first";
						}
						break;
					case "security":
						if (securityData) {
							displaySecurityResultHTML(securityData);
							statusReady.textContent = "Security view - Analysis complete";
						} else if (currentFile) {
							codeContent.textContent = getSecurityView();
							statusReady.textContent = "Security view - Ready for analysis";
						} else {
							codeContent.textContent = getSecurityView();
							statusReady.textContent = "Security view - Upload a file first";
						}
						break;
					case "calculation":
						displayCalculationGuide();
						statusReady.textContent =
							"Calculation Guide - Static explanation of threat scoring";
						break;
				}
			}

			// HTML Table with Proper Formatting - NO BULLETS
			function displaySecurityResultHTML(result) {
				const functions = result.json_report?.functions || [];
				const metrics = result.security_metrics?.metrics || {};
				const radar = result.security_metrics?.radar_data || {};

				// Calculate threat percentages
				const maliciousCount = metrics.malicious_functions || 0;
				const totalCount = functions.length;
				const threatPercent = metrics.threat_percentage || 0;

				// Determine overall threat level
				const threatLevel = radar.threat_level || "unknown";
				const threatLevelDisplay = threatLevel.toUpperCase();

				// Sort functions: malicious first, then by confidence (descending)
				const sortedFunctions = [...functions].sort((a, b) => {
					const aMalicious = a.classification?.malicious === true;
					const bMalicious = b.classification?.malicious === true;
					const aConf = a.classification?.confidence || 0;
					const bConf = b.classification?.confidence || 0;

					if (aMalicious && !bMalicious) return -1;
					if (!aMalicious && bMalicious) return 1;
					return bConf - aConf;
				});

				// Build HTML content
				let htmlContent = '<div class="security-report">';

				// Report header
				htmlContent += '<div class="report-header">';
				htmlContent += '<div class="report-title">SECURITY ANALYSIS</div>';
				htmlContent +=
					'<div class="report-meta">===============================================================================</div>';
				htmlContent += `<div class="report-meta">File: ${
					result.file_analyzed || currentFile.name
				}</div>`;
				htmlContent += `<div class="report-meta">Date: ${new Date().toLocaleString()}</div>`;
				htmlContent += `<div class="report-meta">Overall Threat: ${threatLevelDisplay} | Malicious: ${maliciousCount} of ${totalCount} | Threat %: ${threatPercent}%</div>`;
				htmlContent += "</div>";

				// Create table
				htmlContent += "<table><thead><tr>";
				htmlContent += "<th>No.</th>";
				htmlContent += "<th>Function Name (Conf.)</th>";
				htmlContent += "<th>Status</th>";
				htmlContent += "<th>Behaviors/APIs</th>";
				htmlContent += "<th>Main Threat & Explanation</th>";
				htmlContent += "</tr></thead><tbody>";

				// Add table rows
				sortedFunctions.forEach((func, index) => {
					const funcName = func.function;
					const confidence = Math.round(
						(func.classification?.confidence || 0) * 100
					);
					const isMalicious = func.classification?.malicious === true;

					// Determine status
					let statusText = "BENIGN";
					let statusClass = "";
					if (isMalicious) {
						statusText = "MALICIOUS";
						statusClass = "malicious";
					} else if (
						confidence > 50 &&
						(func.classification?.behavioral_actions || []).length > 0
					) {
						statusText = "SUSPICIOUS";
						statusClass = "suspicious";
					} else {
						statusClass = "benign";
					}

					// Get behaviors and APIs
					const behaviors = func.classification?.behavioral_actions || [];
					let behaviorsText = "";
					let apiText = "";

					if (behaviors.length > 0) {
						const behaviorNames = behaviors.map((b) => b.behavior).join(", ");
						behaviorsText = behaviorNames;

						// Extract APIs from behaviors
						const apis = behaviors
							.flatMap((b) => b.apis || [])
							.filter((api) => api && api.trim() !== "");
						if (apis.length > 0) {
							const uniqueApis = [...new Set(apis)];
							apiText = `<br><small>APIs: ${uniqueApis.join(", ")}</small>`;
						}
					} else {
						behaviorsText = "None detected";
					}

					// Get and format explanation - NO BULLETS
					let explanation = func.classification?.explanation || "";
					explanation = formatExplanationText(explanation);

					// Add row to table
					htmlContent += "<tr>";
					htmlContent += `<td style="text-align: center;">${index + 1}</td>`;
					htmlContent += `<td><strong>${funcName}</strong><br><small>(${confidence}%)</small></td>`;
					htmlContent += `<td style="text-align: center; font-weight: bold; ${
						statusClass === "malicious"
							? "color: #c00;"
							: statusClass === "suspicious"
							? "color: #856404;"
							: "color: #155724;"
					}">${statusText}</td>`;
					htmlContent += `<td>${behaviorsText}${apiText}</td>`;
					htmlContent += `<td>${explanation}</td>`;
					htmlContent += "</tr>";
				});

				// Close table
				htmlContent += "</tbody></table>";

				// Add threat summary
				htmlContent += '<div class="section-divider"></div>';
				htmlContent +=
					'<div class="report-title">THREAT ANALYSIS SUMMARY</div>';
				htmlContent +=
					'<div class="report-meta">===============================================================================</div>';

				if (radar.labels && radar.data) {
					const highRisk = [];
					const mediumRisk = [];
					const lowRisk = [];

					radar.labels.forEach((label, index) => {
						const percentage = Math.round(radar.data[index] || 0);

						if (percentage >= 70) {
							highRisk.push({ label, percentage });
						} else if (percentage >= 40) {
							mediumRisk.push({ label, percentage });
						} else if (percentage > 0) {
							lowRisk.push({ label, percentage });
						}
					});

					if (highRisk.length > 0) {
						htmlContent += "<div><strong>HIGH RISK CATEGORIES:</strong></div>";
						highRisk.forEach((cat) => {
							htmlContent += `<div>${cat.label.replace(/_/g, " ")}: ${
								cat.percentage
							}% - ${getCategoryDescription(cat.label)}</div>`;
						});
						htmlContent += "<br>";
					}

					if (mediumRisk.length > 0) {
						htmlContent +=
							"<div><strong>MEDIUM RISK CATEGORIES:</strong></div>";
						mediumRisk.forEach((cat) => {
							htmlContent += `<div>${cat.label.replace(/_/g, " ")}: ${
								cat.percentage
							}% - ${getCategoryDescription(cat.label)}</div>`;
						});
						htmlContent += "<br>";
					}

					if (lowRisk.length > 0) {
						htmlContent += "<div><strong>LOW RISK CATEGORIES:</strong></div>";
						lowRisk.forEach((cat) => {
							htmlContent += `<div>${cat.label.replace(/_/g, " ")}: ${
								cat.percentage
							}% - ${getCategoryDescription(cat.label)}</div>`;
						});
						htmlContent += "<br>";
					}

					// Add remaining categories with 0%
					const zeroCategories = SECURITY_CATEGORIES.filter(
						(cat) =>
							!radar.labels.includes(cat) ||
							radar.data[radar.labels.indexOf(cat)] === 0
					);

					if (zeroCategories.length > 0) {
						htmlContent += "<div><strong>NO RISK DETECTED:</strong></div>";
						zeroCategories.forEach((cat) => {
							htmlContent += `<div>${cat.replace(/_/g, " ")}: 0%</div>`;
						});
						htmlContent += "<br>";
					}
				} else {
					htmlContent += "<div>No threat category data available</div>";
				}

				// Add overall recommendation
				htmlContent += '<div class="section-divider"></div>';
				htmlContent += '<div class="report-title">OVERALL RECOMMENDATION</div>';
				htmlContent +=
					'<div class="report-meta">===============================================================================</div>';
				htmlContent += '<div class="recommendation">';
				htmlContent += getRecommendation(
					threatLevel,
					maliciousCount,
					threatPercent
				);
				htmlContent += "</div>";
				htmlContent += "</div>";

				// Set HTML content
				codeContent.innerHTML = htmlContent;
				statusReady.textContent = `Security analysis complete - ${maliciousCount} malicious functions detected`;
			}

			function formatExplanationText(text) {
				if (!text) return "No explanation available.";

				// Remove all bullet characters and dashes
				text = text.replace(/-\s*/g, "");

				// Remove extra spaces and normalize
				text = text.replace(/\s+/g, " ").trim();

				// Split by key sections
				const sections = text.split(
					/(?=Confidence:|High-level malicious intent inferred:|Observed malicious behaviors:|Key extracted signals include:)/
				);

				let result = "";

				sections.forEach((section) => {
					section = section.trim();

					if (section.startsWith("Recommendation:")) {
						section =
							"<strong>Recommendation:</strong> " +
							section.substring("Recommendation:".length).trim();
						result += section + "<br><br>";
					} else if (
						section.startsWith("High-level malicious intent inferred:")
					) {
						let intentText = section
							.substring("High-level malicious intent inferred:".length)
							.trim();
						// Clean up formatting
						intentText = intentText.replace(/\s*:\s*/, ": ");
						result +=
							"<strong>High-level malicious intent inferred:</strong><br>";
						result += intentText + "<br><br>";
					} else if (section.startsWith("Observed malicious behaviors:")) {
						let behaviorsText = section
							.substring("Observed malicious behaviors:".length)
							.trim();
						result += "<strong>Observed malicious behaviors:</strong><br>";
						result += behaviorsText + "<br><br>";
					} else if (section.startsWith("Key extracted signals include:")) {
						let signalsText = section
							.substring("Key extracted signals include:".length)
							.trim();
						// Clean up JSON formatting
						signalsText = signalsText.replace(
							/\{'type': 'api_category', 'category': '([^']+)', 'count': (\d+)\}/g,
							"$1 APIs (count: $2)"
						);
						result += "<strong>Key extracted signals include:</strong><br>";
						result += signalsText + "<br><br>";
					}
				});

				// Clean up multiple line breaks
				result = result.replace(/(<br>\s*){3,}/g, "<br><br>");
				result = result.replace(/^<br>+/, "");
				result = result.replace(/<br>+$/, "");

				return result || "No explanation available.";
			}

			// Helper function to get category description
			function getCategoryDescription(category) {
				const descriptions = {
					DATA_EXFILTRATION:
						"Multiple functions attempting unauthorized data transmission",
					PERSISTENCE: "Maintaining access after initial compromise",
					PRIVILEGE_ESCALATION: "Privilege manipulation detected",
					SURVEILLANCE: "Monitoring system activity",
					DESTRUCTIVE: "Damaging or deleting system resources",
					EVASION: "Some evasion techniques present",
					DENIAL_OF_SERVICE: "Potential system resource denial attacks",
					CREDENTIAL_THEFT: "Stealing authentication credentials",
				};
				return descriptions[category] || "Malicious activity detected";
			}

			// Get recommendation based on threat level
			function getRecommendation(threatLevel, maliciousCount, threatPercent) {
				switch (threatLevel) {
					case "high":
						return `IMMEDIATE QUARANTINE REQUIRED: This file contains ${maliciousCount} malicious functions with high confidence scores (${threatPercent}%). Primary threats include data exfiltration, denial of service, and privilege escalation. Do not execute in production environment.`;
					case "medium":
						return `REVIEW REQUIRED: This file contains ${maliciousCount} malicious functions with moderate to high confidence (${threatPercent}%). Suspicious behaviors detected that require investigation. Execute only in isolated, controlled environments.`;
					case "low":
						return `LOW RISK: Minimal malicious behavior detected (${threatPercent}% overall threat). The file appears to be mostly benign with some suspicious indicators. Safe for execution in monitored environments.`;
					default:
						return `INCONCLUSIVE: Insufficient data for complete assessment. Manual review recommended before any execution. Exercise caution when handling this file.`;
				}
			}

			// Display calculation guide
			function displayCalculationGuide() {
				const guideContent = `╔══════════════════════════════════════════════════════════════════════════╗
║                     THREAT BAR CALCULATION GUIDE                         ║
╚══════════════════════════════════════════════════════════════════════════╝

EXAMPLE: Banking Trojan Analysis (bankstealer.exe)

===============================================================================
1. INPUT DATA FROM SECURITY ANALYSIS API
===============================================================================

• Total functions analyzed: 20
• Malicious functions detected: 3
• Threat Percentage = (3 ÷ 20) × 100 = 15%

===============================================================================
2. FUNCTION 1: "steal_credentials" (confidence: 87%)
===============================================================================

BEHAVIORAL ACTIONS (weight: 1.0):
1. "credential" → CREDENTIAL_THEFT
   Score = 0.87 × 100 × 1.0 = 87.0 points

2. "file_access" → DATA_EXFILTRATION
   Score = 0.87 × 100 × 1.0 = 87.0 points

TRIGGERS (weight: 0.5):
• "credential" count=2 → CREDENTIAL_THEFT
  Score = 0.87 × 100 × 0.5 × 2 = 87.0 points

EXPLANATION MENTIONS (weight: 0.3):
• Text mentions "CREDENTIAL_THEFT" → CREDENTIAL_THEFT
  Score = 0.87 × 100 × 0.3 = 26.1 points

• Text mentions "DATA_EXFILTRATION" → DATA_EXFILTRATION
  Score = 0.87 × 100 × 0.3 = 26.1 points

FUNCTION 1 TOTALS:
CREDENTIAL_THEFT = 87.0 + 87.0 + 26.1 = 200.1 → CAPPED TO 100
DATA_EXFILTRATION = 87.0 + 26.1 = 113.1 → CAPPED TO 100

===============================================================================
3. FUNCTION 2: "send_to_server" (confidence: 92%)
===============================================================================

BEHAVIORAL ACTIONS (weight: 1.0):
1. "network" → DATA_EXFILTRATION
   Score = 0.92 × 100 × 1.0 = 92.0 points

2. "evasion" → EVASION
   Score = 0.92 × 100 × 1.0 = 92.0 points

TRIGGERS (weight: 0.5):
1. "network" count=3 → DATA_EXFILTRATION
   Score = 0.92 × 100 × 0.5 × 3 = 138.0 points

2. "evasion" count=1 → EVASION
   Score = 0.92 × 100 × 0.5 × 1 = 46.0 points

FUNCTION 2 TOTALS:
DATA_EXFILTRATION = 92.0 + 138.0 = 230.0 → CAPPED TO 100
EVASION = 92.0 + 46.0 = 138.0 → CAPPED TO 100

===============================================================================
4. FUNCTION 3: "install_persistence" (confidence: 76%)
===============================================================================

BEHAVIORAL ACTIONS (weight: 1.0):
1. "persistence" → PERSISTENCE
   Score = 0.76 × 100 × 1.0 = 76.0 points

FUNCTION 3 TOTALS:
PERSISTENCE = 76.0

===============================================================================
5. COMBINE ALL FUNCTION SCORES
===============================================================================

CATEGORY               FUNCTION 1  FUNCTION 2  FUNCTION 3  TOTAL  CAPPED
──────────────────────────────────────────────────────────────────────────
DATA_EXFILTRATION         100         100          0        200    → 100
CREDENTIAL_THEFT          100           0          0        100    → 100
EVASION                     0         100          0        100    → 100
PERSISTENCE                 0           0         76         76    → 76
PRIVILEGE_ESCALATION        0           0          0          0    → 0
SURVEILLANCE                0           0          0          0    → 0
DESTRUCTIVE                 0           0          0          0    → 0
DENIAL_OF_SERVICE           0           0          0          0    → 0

===============================================================================
6. FINAL THREAT LEVEL CALCULATION
===============================================================================

Average Score = (100 + 76 + 0 + 0 + 0 + 100 + 0 + 100) ÷ 8 = 376 ÷ 8 = 47.0

THREAT LEVEL DETERMINATION:
• 47.0 > 40 but < 70 → Threat Level = "MEDIUM"

===============================================================================
7. VISUALIZATION IN THREAT BARS
===============================================================================

DATA_EXFILTRATION      ██████████ 100%  (HIGH RISK)
PERSISTENCE            ███████░░░  76%  (HIGH RISK)  
PRIVILEGE_ESCALATION   ░░░░░░░░░░   0%  (NO RISK)
SURVEILLANCE           ░░░░░░░░░░   0%  (NO RISK)
DESTRUCTIVE            ░░░░░░░░░░   0%  (NO RISK)
EVASION                ██████████ 100%  (HIGH RISK)
DENIAL_OF_SERVICE      ░░░░░░░░░░   0%  (NO RISK)
CREDENTIAL_THEFT       ██████████ 100%  (HIGH RISK)

===============================================================================
8. KEY FORMULAS
===============================================================================

1. Threat Percentage = (Malicious Functions ÷ Total Functions) × 100

2. Category Score = Σ(Confidence × 100 × Weight × Evidence)

   Weights:
   • Behavioral Actions: 1.0
   • API Triggers: 0.5 × count
   • Text Mentions: 0.3

3. Normalization: Score = min(100, max(0, Raw Score))

4. Threat Level:
   • HIGH: Average Score > 70%
   • MEDIUM: 40% ≤ Average Score ≤ 70%
   • LOW: 0% < Average Score < 40%
   • UNKNOWN: Average Score = 0%

===============================================================================
9. TOOLTIP INFORMATION
===============================================================================

Hover over threat bars to see contributing functions:
• DATA_EXFILTRATION (100%):
  - steal_credentials (87% confidence)
  - send_to_server (92% confidence)

• CREDENTIAL_THEFT (100%):
  - steal_credentials (87% confidence)

• EVASION (100%):
  - send_to_server (92% confidence)

• PERSISTENCE (76%):
  - install_persistence (76% confidence)

===============================================================================
INTERPRETATION:
This malware steals data (100%), steals passwords (100%), tries to hide (100%),
and installs itself permanently (76%). Overall threat level is MEDIUM (47/100).
`;

				codeContent.textContent = guideContent;
			}

			// Display Ghidra result
			function displayGhidraResult(result) {
				codeContent.textContent = `/* Ghidra Decompilation Output */
/* File: ${currentFile.name} */
/* Analysis Time: ${result.ghidra_time}s */

${result.decompiled_code}`;

				statusReady.textContent =
					"Ghidra decompilation complete - Ready for further analysis";

				updateResults({
					complexity: "Calculating...",
					threat: "Pending",
					vulns: "Pending",
					size: formatFileSize(currentFile.size),
				});
			}

			// Display enhanced result
			function displayEnhancedResult(result) {
				codeContent.textContent = `/* Heuristic Enhanced Decompilation */
/* File: ${currentFile.name} */
/* Ghidra Time: ${result.ghidra_time}s | Enhancement Time: ${result.enhancement_time}s */
/* Enhancement Status: ${result.enhancement_status} */

${result.decompiled_code}`;

				statusReady.textContent =
					"Heuristic enhancement complete - Ready for security analysis";

				updateResults({
					complexity: "Enhanced",
					threat: "Pending",
					vulns: "Pending",
					size: formatFileSize(currentFile.size),
				});
			}

			// ==================== THREAT BARS FUNCTIONS ====================

			// Create a single threat bar element with tooltip
			function createThreatBar(
				category,
				percentage,
				contributingFunctions = []
			) {
				// Determine threat level and color class
				let threatClass, colorClass;
				if (percentage >= 70) {
					threatClass = "high";
					colorClass = "high";
				} else if (percentage >= 40) {
					threatClass = "medium";
					colorClass = "medium";
				} else if (percentage > 0) {
					threatClass = "low";
					colorClass = "low";
				} else {
					threatClass = "none";
					colorClass = "empty";
				}

				// Format category name for display
				const displayName = category.replace(/_/g, " ");

				// Create tooltip content
				let tooltipContent = `<strong>${displayName}: ${Math.round(
					percentage
				)}%</strong>`;

				if (contributingFunctions.length > 0) {
					tooltipContent += `<br><small>Contributing functions:</small><br>`;
					contributingFunctions.forEach((func) => {
						tooltipContent += `• ${func.name} (${func.confidence}% confidence)<br>`;
					});
				} else {
					tooltipContent += `<br><small>No specific malicious functions detected</small>`;
				}

				// Create the bar element
				const barElement = document.createElement("div");
				barElement.className = "threat-bar";
				barElement.innerHTML = `
					<div class="threat-bar-label">
						<div class="threat-name" title="${displayName}">${displayName}</div>
						<div class="threat-percentage">${Math.round(percentage)}%</div>
					</div>
					<div class="threat-bar-track">
						<div class="threat-bar-fill ${colorClass}" style="width: ${percentage}%" 
							 data-tooltip="${tooltipContent.replace(/"/g, "&quot;")}"></div>
					</div>
				`;

				// Add hover event for tooltip
				const barFill = barElement.querySelector(".threat-bar-fill");
				barFill.addEventListener("mouseenter", showTooltip);
				barFill.addEventListener("mouseleave", hideTooltip);

				return barElement;
			}

			// Show tooltip on hover
			function showTooltip(e) {
				const tooltipText = e.target.getAttribute("data-tooltip");
				const tooltip = document.createElement("div");
				tooltip.className = "threat-tooltip";
				tooltip.innerHTML = tooltipText;

				// Position tooltip
				const rect = e.target.getBoundingClientRect();
				const scrollLeft =
					window.pageXOffset || document.documentElement.scrollLeft;
				const scrollTop =
					window.pageYOffset || document.documentElement.scrollTop;
				tooltip.style.left = rect.left + scrollLeft + "px";
				tooltip.style.top =
					rect.top + scrollTop - tooltip.offsetHeight - 10 + "px";

				// Add to document
				document.body.appendChild(tooltip);

				// Show with slight delay
				setTimeout(() => {
					tooltip.classList.add("show");
				}, 10);

				// Store reference for removal
				e.target._tooltip = tooltip;
			}

			// Hide tooltip
			function hideTooltip(e) {
				if (e.target._tooltip) {
					e.target._tooltip.remove();
					e.target._tooltip = null;
				}
			}

			// Update threat bars from security data
			function updateThreatBarsFromSecurity(result) {
				const radarData = result.security_metrics?.radar_data;

				// Use structured radar data if available
				if (radarData && radarData.data && radarData.data.length > 0) {
					updateAllThreatBars({
						labels: radarData.labels || SECURITY_CATEGORIES,
						data: radarData.data,
						threatLevel: radarData.threat_level || "unknown",
						contributingFunctions: radarData.contributing_functions || {},
					});
					return;
				}

				// If no structured data, show empty bars
				resetThreatBars();
			}

			// Update all threat bars
			function updateAllThreatBars(threatData) {
				// Hide placeholder
				threatPlaceholder.style.display = "none";

				// Clear existing bars
				const existingBars = threatBarsWrapper.querySelectorAll(".threat-bar");
				existingBars.forEach((bar) => bar.remove());

				// Update threat level indicator
				const levelText =
					threatData.threatLevel.charAt(0).toUpperCase() +
					threatData.threatLevel.slice(1);
				threatLevel.textContent = levelText;
				threatLevel.className = "threat-level " + threatData.threatLevel;

				// Create bars for all categories
				threatData.labels.forEach((label, index) => {
					const percentage = threatData.data[index] || 0;
					const contributingFunctions =
						threatData.contributingFunctions?.[label] || [];
					const bar = createThreatBar(label, percentage, contributingFunctions);
					threatBarsWrapper.appendChild(bar);
				});

				// Add a subtle animation delay for each bar
				setTimeout(() => {
					const bars = threatBarsWrapper.querySelectorAll(".threat-bar-fill");
					bars.forEach((bar, index) => {
						setTimeout(() => {
							bar.style.transition = "width 0.8s ease-out";
						}, index * 50);
					});
				}, 100);
			}

			// Reset threat bars to placeholder state
			function resetThreatBars() {
				// Remove all threat bars
				const existingBars = threatBarsWrapper.querySelectorAll(".threat-bar");
				existingBars.forEach((bar) => bar.remove());

				// Show placeholder
				threatPlaceholder.style.display = "flex";

				// Reset threat level
				threatLevel.textContent = "No Data";
				threatLevel.className = "threat-level unknown";
			}

			// Update results from security data
			function updateResultsFromSecurity(result) {
				const metrics = result.security_metrics?.metrics;
				if (!metrics) return;

				updateResults({
					complexity: metrics.complexity || "Unknown",
					threat: `${metrics.threat_percentage || 0}%`,
					vulns: metrics.malicious_functions || 0,
					size: formatFileSize(currentFile.size),
				});
			}

			// ==================== HELPER FUNCTIONS ====================

			// Update results panel
			function updateResults(results) {
				document
					.getElementById("resultComplexity")
					.querySelector(".result-value").textContent = results.complexity;
				document
					.getElementById("resultThreat")
					.querySelector(".result-value").textContent = results.threat;
				document
					.getElementById("resultVulns")
					.querySelector(".result-value").textContent = results.vulns;
				document
					.getElementById("resultSize")
					.querySelector(".result-value").textContent = results.size;

				resultBoxes.forEach((box) => box.classList.add("active"));
			}

			// Export current view
			function exportCurrentView() {
				let content = codeContent.textContent;
				const blob = new Blob([content], { type: "text/plain" });
				const url = URL.createObjectURL(blob);
				const a = document.createElement("a");
				a.href = url;

				let filename = currentFile.name.replace(/\.[^/.]+$/, "");
				if (currentView === "ghidra") filename += "_ghidra";
				else if (currentView === "heuristic") filename += "_enhanced";
				else if (currentView === "security") filename += "_security";
				else if (currentView === "calculation")
					filename += "_calculation_guide";
				else filename += "_raw";
				filename += ".txt";

				a.download = filename;
				a.click();
				showNotification(`Exported as ${filename}`);
			}

			// Show progress animation
			function showProgress(text, duration, callback) {
				progressText.textContent = text;
				progressOverlay.style.display = "flex";
				progressFill.style.width = "0%";

				if (duration === 0) {
					progressFill.style.width = "30%";
					progressFill.style.animation = "pulse 2s infinite";
					return;
				}

				let progress = 0;
				const interval = setInterval(() => {
					progress += 2;
					progressFill.style.width = `${progress}%`;

					if (progress >= 100) {
						clearInterval(interval);
						setTimeout(() => {
							progressOverlay.style.display = "none";
							progressFill.style.width = "0%";
							progressFill.style.animation = "none";
							if (callback) callback();
						}, 500);
					}
				}, duration / 50);
			}

			// Hide progress
			function hideProgress() {
				progressOverlay.style.display = "none";
				progressFill.style.width = "0%";
				progressFill.style.animation = "none";
			}

			// Show error modal
			function showError(title, message) {
				modalTitle.textContent = title;
				modalBody.textContent = message;
				errorModal.style.display = "flex";
			}

			// Hide modal
			function hideModal() {
				errorModal.style.display = "none";
			}

			// Show notification
			function showNotification(message) {
				const notification = document.createElement("div");
				notification.textContent = message;
				notification.style.cssText = `
					position: fixed;
					top: 20px;
					right: 20px;
					background: #10b981;
					color: white;
					padding: 10px 16px;
					border-radius: 5px;
					box-shadow: 0 4px 12px rgba(0,0,0,0.15);
					z-index: 1001;
					font-size: 13px;
				`;
				document.body.appendChild(notification);

				setTimeout(() => notification.remove(), 3000);
			}

			// Get raw content view
			function getRawContentView() {
				if (!currentFile || !fileContent) return "No file content available";

				if (
					currentFile.name.endsWith(".o") ||
					currentFile.name.endsWith(".obj")
				) {
					return `Raw File Content - ${currentFile.name}
Size: ${formatFileSize(currentFile.size)}
Format: Object File

${fileContent}`;
				} else {
					let hexView = `Raw Binary Content - ${currentFile.name}
Size: ${formatFileSize(currentFile.size)}
Format: Binary/Executable

Hex Dump (first 1024 bytes):\n`;

					if (fileContent instanceof ArrayBuffer) {
						const bytes = new Uint8Array(fileContent.slice(0, 1024));
						for (let i = 0; i < bytes.length; i += 16) {
							let hex = "";
							let ascii = "";
							for (let j = 0; j < 16; j++) {
								if (i + j < bytes.length) {
									const byte = bytes[i + j];
									hex += byte.toString(16).padStart(2, "0") + " ";
									ascii +=
										byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : ".";
								} else {
									hex += "   ";
								}
							}
							hexView += `${i
								.toString(16)
								.padStart(8, "0")}: ${hex} ${ascii}\n`;
						}
						if (currentFile.size > 1024) {
							hexView += `\n... (${
								currentFile.size - 1024
							} more bytes truncated)`;
						}
					}

					return hexView;
				}
			}

			// View content functions (initial views)
			function getRawView() {
				return "Upload a file to see raw content\n\nSupported formats: .bin, .exe, .o, .obj, .elf, .so, .dll, .py\n\nOnce uploaded, raw file content will be displayed here automatically.";
			}

			function getGhidraView() {
				return `Ghidra Output View - Ready for Analysis
File: ${currentFile ? currentFile.name : "No file"}
Size: ${currentFile ? formatFileSize(currentFile.size) : "—"}

Click the play button (▶) to run Ghidra decompilation.

Note: Ghidra analysis may take 30-60 seconds for large files.`;
			}

			function getHeuristicView() {
				return `Heuristic Enhanced View - Ready for Analysis
File: ${currentFile ? currentFile.name : "No file"}
Size: ${currentFile ? formatFileSize(currentFile.size) : "—"}

Click the play button (▶) to run heuristic enhancement.

Note: Requires Ghidra decompilation first.`;
			}

			function getSecurityView() {
				return `Security View - Ready for Analysis
File: ${currentFile ? currentFile.name : "No file"}
Size: ${currentFile ? formatFileSize(currentFile.size) : "—"}

Click the play button (▶) to run security scan.

Note: Requires Ghidra decompilation first.`;
			}

			// Helper functions
			function formatFileSize(bytes) {
				if (bytes === 0) return "0 Bytes";
				const k = 1024;
				const sizes = ["Bytes", "KB", "MB", "GB"];
				const i = Math.floor(Math.log(bytes) / Math.log(k));
				return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
			}

			// Initialize
			document.addEventListener("DOMContentLoaded", () => {
				console.log(
					"DeMa-AI Analysis Platform loaded with fixed security report formatting"
				);
				// Set up initial threat bars placeholder
				resetThreatBars();
			});
		</script>
	</body>
</html>
